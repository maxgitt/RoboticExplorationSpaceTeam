#include <Beacon/Beacon.h>
#include <iostream>
#include <limits>
using std::deque;
using std::numeric_limits;
RoverBeacon::RoverBeacon(string id_) : id(id_){}

RoverBeacon::RoverBeacon(string id_, 
	vector<pair<int, sieveBeaconData>> sieveBeacons, 
		pair<double,double> roverOffset) : id(id_), 
			offset(roverOffset) {
	// loop through the sieveBeacon vector to intialize the rover
	// beacon;
	for(auto beacon: sieveBeacons){ 
		// store the id of the sieve beacon 
		// and its associated data
		beaconReadings.insert({beacon.first, beacon.second}); 
	}
}

double 
RoverBeacon::getReading(int id_){
	beaconIterator = beaconReadings.find(id_);
	return beaconIterator->second.reading;
}


void 
RoverBeacon::updateReading(int id_, double reading_){
	//cout << "You are updating the distance between " 
    //<< id << " and " << id_ << " to be " << reading_ << endl;
	beaconIterator = beaconReadings.find(id_);
	//cout << "The bias we have for " << id_ << " is " << beaconIterator->second.bias;
	/*
	double temp_reading = reading_- beaconIterator->second.bias;
	if (beaconIterator->second.all_readings.size() == 10) {
		beaconIterator->second.all_readings.pop_front();
	}
	beaconIterator->second.all_readings.push_back(temp_reading);
	temp_reading = 0;
	for (deque<double>::iterator it = beaconIterator->second.all_readings.begin(); it != beaconIterator->second.all_readings.end(); ++it) {
		temp_reading += *it;
	}
	beaconIterator->second.reading = temp_reading / beaconIterator->second.all_readings.size();
	*/
	beaconIterator->second.reading = reading_ - beaconIterator->second.bias;
	positionUpdated = false;

}

double 
RoverBeacon::getBias(int id_){
	beaconIterator = beaconReadings.find(id_);
	return beaconIterator->second.bias;
}

void 
RoverBeacon::updateBias(int id_, double bias_){
	std::cout << "enter updateBias with following value: " << bias_ << endl;
	beaconIterator = beaconReadings.find(id_);
	beaconIterator->second.bias = bias_;
	std::cout << "leaving updateBias" << endl;
}

pair<double,double>
RoverBeacon::getPosition(){
	//Position of the Beacon should only be updated 
	//if new readings have been taken
	if(!positionUpdated) {
		updatePosition();
		positionUpdated = true;
	}
	return position;
}

std::unordered_map<int, RoverBeacon::sieveBeaconData> RoverBeacon::getBeaconReadings () {
    return beaconReadings;
}

void
RoverBeacon::updatePosition(){
	vector<double> readings;
	vector<pair<double,double>> offsets;
	auto it = beaconReadings.begin();
	auto endIt = beaconReadings.end();
	for (; it != endIt; ++it) {
		readings.push_back(it->second.reading);
		offsets.push_back(it->second.offset);
	}
	position = steepest_descent(readings,offsets, position);

}

string
RoverBeacon::getId(){
	return id;
}

pair<double, double>
RoverBeacon::getOffset() {
    return offset;
}

double 
beaconError(double r_1, double h_1, double k_1, 
                                 const pair<double, double>& guess) {
    double error_1;
    double diff_x_1, diff_y_1; //edges of triangles
    double dist_1; //distance of guess from beacon
    diff_x_1 = guess.first - h_1; //bottom edge of triangle
    diff_y_1 = guess.second - k_1;
    dist_1 = sqrt(diff_x_1 * diff_x_1 + diff_y_1 * diff_y_1); //pythagorean theorem
    error_1 = dist_1 - r_1;
    return error_1;
}


double 
beaconPartialY(double r_1, double h_1, double k_1, 
                            		const pair<double, double>& guess) {
    double diff_x_1, diff_y_1; //edges of triangles
    double dist_1;
    diff_x_1 = guess.first - h_1; //bottom edge of triangle
    diff_y_1 = guess.second - k_1;   
    dist_1 = sqrt(diff_x_1 * diff_x_1 + diff_y_1 * diff_y_1); //pythagorean theorem
    double circle1Deriv = diff_y_1/dist_1;
    if (dist_1 < r_1) {
        circle1Deriv *= -1;
    }
    return circle1Deriv;
}


double 
beaconPartialX(double r_1, double h_1, double k_1, 
									const pair<double, double>& guess) {
    double diff_x_1, diff_y_1;  //edges of triangles
    double dist_1; //distance of guess from beacon
    diff_x_1 = guess.first - h_1; //bottom edge of triangle
    diff_y_1 = guess.second - k_1;
    dist_1 = sqrt(diff_x_1 * diff_x_1 + diff_y_1 * diff_y_1); //pythagorean theorem   
    double circle1Deriv = diff_x_1/dist_1;
    if (dist_1 < r_1) {
        circle1Deriv *= -1;
    }
    return circle1Deriv;
}


double 
calcError(const vector<double>& readings, 
						const vector<pair<double,double>>& offsets, 
							const pair<double, double>  guess);

double 
calcPartialX(const vector<double>& readings, 
                const vector<pair<double,double>>& offsets,
 										const pair<double, double>  guess);

double 
calcPartialY(const vector<double>& readings, 
                    	const vector<pair<double,double>>& offsets,
												const pair<double, double>  guess);
pair<double, double> 
RoverBeacon::steepest_descent(const vector<double>& readings, 
                              const vector<pair<double,double>>& offsets,
                                  pair<double, double>  old_pos) {
    pair<double, double> new_pos;
    double x_deriv, y_deriv;
    double current_error, past_error;
    double error_diff = 10;
    double threshold = 0.00000005;
  
    new_pos = old_pos;
    current_error = numeric_limits<double>::max();
    past_error = numeric_limits<double>::min();
  
    while ( error_diff > threshold) {
        old_pos = new_pos;
        x_deriv = calcPartialX(readings, offsets, new_pos);
        y_deriv = calcPartialY(readings, offsets, new_pos);
        new_pos.first = new_pos.first - x_deriv * 0.1;
        new_pos.second = new_pos.second - y_deriv * 0.1;
        past_error = current_error;
        current_error = calcError(readings, offsets, new_pos);
        error_diff = abs(past_error - current_error);    
    }
    return new_pos;
}

double 
calcError(const vector<double>& readings, const vector<pair<double,double>>& offsets, const pair<double, double>  guess) {
    double error = 0;
    for (int i = 0; i < readings.size(); ++i) {
        error += beaconError(readings.at(i), offsets.at(i).first, offsets.at(i).second, guess);
    }
    return error;
}


double 
calcPartialX(const vector<double>& readings, 
             		const vector<pair<double,double>>& offsets,
                    const pair<double, double>  guess) {
    double partialX = 0;
    for (int i = 0; i < readings.size(); ++i) {
        partialX += beaconPartialX(readings.at(i), offsets.at(i).first, offsets.at(i).second, guess);

    }
    return partialX;
}


double 
calcPartialY(const vector<double>& readings, 
             		const vector<pair<double,double>>& offsets,

                    const pair<double, double>  guess) {
    double partialY = 0;
    for (int i = 0; i < readings.size(); ++i) {
        partialY += beaconPartialY(readings.at(i), offsets.at(i).first, offsets.at(i).second, guess);
    }
    return partialY;
}





/*
	//vector of x,y coordinates based on all combinations of sieve beacons
	vector<pair<double,double>> positions; 
	unordered_map<int,sieveBeaconData>::const_iterator firstBeacon  = beaconReadings.begin();
	///error must be thrown on need to include in RME that at least two beacons must be present
	if(firstBeacon == beaconReadings.end()) return; 
	unordered_map<int, sieveBeaconData>::const_iterator secondBeacon = ++beaconReadings.begin();
	double x;
	double y;
	while(secondBeacon != beaconReadings.end()){
		while(secondBeacon != beaconReadings.end()){
			pair<double,double> currPosition;
			 cout << "Working with distances from sieve Beacons: " << firstBeacon->first<< ", " << secondBeacon->first
			<< "The data from these Beacons are: " << firstBeacon->second.reading << ", " << secondBeacon->second.reading << " We also incorporate the Biases which for the first beacon are: " <<  firstBeacon->second.offset.first << ", " << firstBeacon->second.offset.second <<" The second Beacon biases are " << secondBeacon->second.offset.first << ", " << secondBeacon->second.offset.second << endl;  

			/* We will use calculate the x and y position of the beacon based on the
			* intersection of the two circles with the radius equal to the distance b/t
			* a sieve beacon and a rover beacon. The offsets will be accounted for 
			* within the equation of the circle. These formulas can be found on:
			* http://www.ambrsoft.com/TrigoCalc/Circles2/Circle2.htm
			
			// Circle one is of the form (x-a)^2 + (y-b)^2 = r0^2 where a is the x offset
			// of the sieve beacon and b is the y offset of the sieve beacon
			double r0 = firstBeacon->second.reading;
			double a = firstBeacon->second.offset.first;
			double b = firstBeacon->second.offset.second;
            
			// Circle two is of the form (x-c)^2 + (y-d)^2 = r1^2 where c is the x offset
			// of the sieve beacon and d is the y offset of the sieve beacon
			double r1 = secondBeacon->second.reading;
			double c = secondBeacon->second.offset.first;
			double d = secondBeacon->second.offset.second;
            
			//Calculate distance betwen circles
			double D = sqrt(pow((c-a),2) + pow((d-b),2));
            
			//Calculate the area of triangle formed by two circle centers
			double triArea = 0.25 * sqrt((D + r0 + r1) * (D + r0 - r1) * (D - r0 + r1) * (-D + r0 + r1));
            
			//There are two intersection points
			double x1 = (a+c)/2 + (((c - a) * (pow(r0,2) - pow(r1,2)))
                        /(2 * pow(D,2))) + 2 * (b - d)/(pow(D,2)) * triArea;
			double x2 = (a+c)/2 + (((c - a) * (pow(r0,2) - pow(r1,2)))
                        /(2 * pow(D,2))) - 2 * (b - d)/(pow(D,2)) * triArea;
			double y1 = (b+d)/2 + (((d - b) * (pow(r0,2) - pow(r1,2)))
                        /(2 * pow(D,2))) - 2 * (a - c)/(pow(D,2)) * triArea;
			double y2 = (b+d)/2 + (((d - b) * (pow(r0,2) - pow(r1,2)))
                        /(2 * pow(D,2))) + 2 * (a - c)/(pow(D,2)) * triArea;
            
			if (y1 < 0) {
			    currPosition.first = x2;
			    currPosition.second = y2;
			}
			else {
			    currPosition.first = x1;
			    currPosition.second = y1;
			}
			//cout << "The position calculated for this particular set of data is " << currPosition.first << ", " << currPosition.second << endl;
			positions.push_back(currPosition);
			++secondBeacon;
        }
        ++firstBeacon;
        secondBeacon = ++firstBeacon;
    }
    //store the average x and y position of this beacon
    for (auto currPos : positions) {
        x += currPos.first;
        y += currPos.second;
    }

    position.first = x/positions.size();
    position.second = y/positions.size();
cout << "id "<< this->getId()<< " x: " << position.first << " y: " << position.second << endl;


*/



