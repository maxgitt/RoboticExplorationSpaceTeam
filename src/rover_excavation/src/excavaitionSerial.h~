#include <ros/ros.h>
#include "serial/serial.h"
#include <iostream>
#include <sstream>
#include <string>

class SerialComm
{
public:
SerialComm();
	serial::Serial * uno_serial;
	void commandLinearActuator(string command);

private:
	int linear_actuator_BAUD_;
	std::string linear_actuator_PORT_;
  ros::NodeHandle nh_;
};

EncoderControl::EncoderControl():
	linear_actuator_BAUD_(9600),
	linear_actuator_PORT_("ttyACM0")
{
	nh_.param("linear_actuator_BAUD", linear_actuator_BAUD_, linear_actuator_BAUD_);
	nh_.param("linear_actuator_PORT", linear_actuator_PORT_, linear_actuator_PORT_);

	try{
		uno_serial = new serial::Serial(linear_actuator_PORT_, linear_actuator_BAUD_, serial::Timeout::simpleTimeout(1000));	
	}
	catch(serial::IOException e){
		std::cerr << "Could not connect\n";
	}
}

void SerialComm::commandLinearActuator()
{
	std::string msg_in = uno_serial->read();
	std::stringstream ss(msg_in);
	
	rover_motor_control::Encoder msg;

	int x;
	char delim;

	ss >> x;
	msg.back_left_ = x;

	ss >> delim;
	ss >> x;
	msg.back_right_ = x;

	ss >> delim;
	ss >> x;
	msg.front_left_ = x;

	ss >> delim;
	ss >> x;
	msg.front_right_ = x;

	encoder_pub_.publish(msg);
}

int main(int argc, char** argv)
{
  ros::init(argc, argv, "encoder_control_REST");
  EncoderControl encoder_control;
	ros::Rate loop_rate(10);
  while (ros::ok()){
		encoder_control.update_encoder();
  	ros::spinOnce();
		loop_rate.sleep();
	}
	delete encoder_control.uno_serial;
	encoder_control.uno_serial = NULL;
}
